#+TITLE: ważne dokumentowanie procesu twórczego
Wielomiany: co robić i jak

* TODO debug

** DONE inicjalizacja koeficji
   wyobraźmy sobie taką sytuację. Sumacja np $x$ i $-x$. Wyjdzie ofc zero. W programie
   mamy tam wielomian z listą jednoelementową z jednomianem o współczynniku 1. Drugi ma
   tam -1. Zatem merge'ując listy dostaniemy rzecz jasna w pewnym momencie ~+=~ na
   jednomianach, które zwróci nam jednomian z zerem w sobie. Więc się go oczywiście
   pozbędziemy. Czyli rezultatem merge'u będzie... NULL! w tym przypadku. Zatem w
   =PolyAddComp= trzeba chyba sprawdzić to. Wielomianowi jeśli z nienull listy zrobi się
   null, to wtw gdy zeracja
   
** DONE SimpleAddMonos:
   teraz wcześniej
   #+begin_src C
     {
       Mono m[] = {M(C(-1), 1), M(C(1), 1)};
       res &= TestAddMonos(2, m, C(0));
     }
   #+end_src
   
   
   linijka 190 w [[file:src/poly_example.c][poly_example.c]]
   #+begin_src C
     {
       Mono m[] = {M(C(1), 0), M(C(1), 0)};
       res &= TestAddMonos(2, m, C(2));
     }
   #+end_src
   jedyny test w =SimpleAddMonosTest= na którym się wywala, ważne dość *todo*
   #+begin_example
     67	  bool is_eq = PolyIsEq(&b, &res);
     (gdb) p b
     $33 = {coeff = 0, list = 0x1003040c0}
     (gdb) p *b.list
     $34 = {m = {p = {coeff = 2, list = 0x0}, exp = 0}, tail = 0x0}
     (gdb) p res
     $35 = {coeff = 2, list = 0x0}
   #+end_example
   Taki błąd -- tworząc z mono ~n == 0~ dostaję nie koef, a ten pseudo koef. Mimo, że
   wynik poprawny, to się popsuje wynik. Brak dekoefizacji?
** DONE =PolyAddMonos= czyli $\sum$
   ok. robiąc =PolyAddMonos= robię zawsze ten sam =elem=. Z tym samym adresem. Przez co
   dodaje się ta sama rzecz kilka raz!

*** =MonoListInsert= -- triple ref
    Przez powyższego buga robię destroy na tej samej rzeczy!
    
** =PolyAddComp= czyli $+=$
   czyli *+=*. Niestety *nie działa* -- nie sprawdzam przypadku gdy $p$ i $q$ to
   wielomiany stałe (lub jeden z nich, tam też /dualizm koeficji/ wejdzie w grę)

** =MakePolyHelper=... czyli ten syf
   Po teście =SimpleAddTest= (ln 117) gdzie wywołuję w helperze PolyAddMonos jakoś po
   powrocie dostaję w wyniku syf
   #+begin_example
     (gdb) p head
     $54 = (MonoList *) 0x7ffeefbfe958
     (gdb) p *head
     $55 = {m = {p = {coeff = 2, list = 0x0}, exp = 0}, tail = 0x0}
     (gdb) s
     492	    .list = head
     (gdb) s
     491	  return (Poly) {
     (gdb) s
     MakePolyHelper (dummy=0) at /Users/grzegorz/Dropbox/C/poly/src/poly_example.c:44
     44	  free(arr);
     (gdb) s
     45	  return res;
     (gdb) p res
     $56 = {coeff = 0, list = 0x7ffeefbfe958}
     (gdb) p *res.list
     $58 = {m = {p = {coeff = 4298113024, list = 0xefbfe9a0}, exp = 7680}, tail = 0x100110000}
   #+end_example
   clearly miałem ładny head (choć błędny vide powyższe bugi), podstawiłem pointer nań do
   tam list, a po zreturnowaniu otrzymałem jakiś syf pod listą... Czemu? Bo to nie był
   wynik mallokacji? wydaje mi się, że wcześniej działało. Chyba head to jest tam zmienna
   stosowa jak i elem i takie coś się dzieje dlatego.

***    *TAK*
    Zwracam head źle. Drugi test to pokazuje. Powinienem malokować tę pamięć, a ja ją
    zwracam cymbalsko. Później gdy przed merge'ując =PolyClone= klona listy to sięgam tam
    pod same nieznane lokacje losowe.

    ergo /wina segmentacyjna/.

    _zwracam wskaźniki na zmienne na stosie!!!_

    Muszę insertując dawać zaalokowane na stercie rzeczy!
* TODO 
  - [ ] nie alokować  na stosie!!!
  - [ ] poukładać kod logicznie, modularyzacja perhaps?
  - [ ] dualizm koeficji
    - [ ] sprawdzian pseudo koeficji naprawić
    - [ ] co zrobić, jeśli gdzieś głęboko jest *zero*
      najlepiej tego w ogole uniknąć, ale nie jest to zawsze możliwe. zatem może jakoś
      pokombinować i np pomyśleć tak -- mnożąc jeśli dostaniemy zero, to je *omijamy* i
      porzucamy. Rekurencją próba wykaraskania się z objęć zera. _TODO ważne_
    - [ ] naprawić test na reduckcję -- *gdzie ma być* =IsPseudo= a *gdzie nie*?
  - [X] lista vs tablica?
    na gałęzi ~use-list~ lista
  - [X] obrócić kolejność jednomów
  - [X] poprawić na ~use-list+=~ wszystko -- kolejność + reformat
  - [X] =PolyAt= *!!!!!*
  - [X] dodawanie
  - [X] mnożenie
  - [X] zacząć
  - [ ] _niech to działa_


** różne
   - [X] polimorficzne tablice
     zrobione przy okazji wierszarza
   - [ ] polimorficzne listy
     - =add=, =append=
     - =map=
     - =car=, =cdr=
     - =fold_left=, =fold_right=
     - =filter=
   - [ ] symulacja pattern matchingu w C

* Lista jednomianów
  Lepiej ją trzymań od największych do najmniejszych wykładników -- prościej policzyć stopień. Poza
  tym pole =size= wtedy traci rację bytu mając listę. 

** TODO dodanie elemtnu do listy, a kopiowanie danych
*** wariant kodu
    mówię o tym
    #+begin_src C
        while ((*tracer && (cmp = MonoCmp(&(*tracer)->m, &new->m)) < 1))
          tracer = &(*tracer)->tail;
  
        if (cmp != 0) {
          /* nowy element o wykładniku niepojawionym jeszcze */
          new->tail = *tracer;
          ,*tracer = new;
        } else {
          /* już jest element z takim wykładnikiem. muszę jakoś zsumować je, ale...
           ,* czy nie chciałbym pamięci marnować. najlepiej byłoby mieć wersję Add
           ,* która by zmieniała jeden z tych dwóch, a nie tworzyła nowy, ale.. ech */
          new->m = MonosAdd(&new->m, &(*tracer)->m);
          MonoDestroy(&(*tracer)->m);
          (*tracer)->m = new->m;
        }
    
      }
    #+end_src
    -- jak tu dodać ten element new, gdy go ,,wtłaczamy'' w ten nowy?
  
*** koncepcja: najpierw ~+=~, a później ~+~
    Jak to ma działać? Otóż może uściślę z czym problem pierwiej. 

**** Chcąc dodać do siebie dwa
     wielomiany $p + q$ oczekiwalibyśby, że robiąc ~Poly new = PolyAdd(&p, &q)~ ani ~q~ ani ~p~ nie
     ulegną zmianie. Zatem ~MonoAdd(m, t)~ siłą rzeczy zadziała podobnie.

     *jednakże*

     problem pojawia się przy wymnażaniu. Celem jest oczywiście pomnożenie każdego elementu z każdym i
     późniejsze zwrócenie wyniku tej operacji. Dostaniemy np

     \[ (x + 1) (x + 1) = x * x + x * 1 + 1 * x + 1 * 1 = x^2 + x + x + 1 = x^2 + 2x + 1  \]

     gdzie kluczowe jest to przejście w ostatnim znaku $=$. W ogólności mając już
     \( ... + p x^n + ... \) gdy wymnożymy kolejne jednomy, możemy dostać \( q x^ n \). Wtedy chcemy
     jedodać i *zmerege'ować*. Tj rezultat taki: \(  ... + (p + q) x^n + ... \). Ale mając funkcje
     ~MonoAdd~ i ~PolyAdd~ we wspomnianej formie, _może to się skomplikować_ -- dodając =m1= do =m2=
     otrzymamy *zupełnie nowe* =m3=, a chcielibyśmy aby =m1 --> m3=. Możemy spróbować to zrobić, ale
     wtedy musimy wcześniej zniszczyć =m1= i jego pamięć. Troszkę bez sensu to się wydaje. 

**** możliwe rozwiązania
    
***** utworzenie nowego, usunięcie starego i podstawienie tam tego utworzonego
      yikes. to co opisałem właśnie tuż powyżej

***** operacje ~+=~
      Jak można przeczytać w [[https://stackoverflow.com/a/4421719][dyskusjach dot. przeciążania operatorów w C++]] wskazanym może
      być pierwiej utworzenie funkcji ~+=~ i później dopiero ~+~ *opartej na tej
      pierwszej*. Łatwo widać czemu to podejście ma sens w tej sytuacji. Kopia następuje
      *jedynie gdy to konieczne*. To rozwiązanie wymaga co prawda pewnego skomplikowania
      operacji ~MonoListsMerge~ (asymetria: dodając elementy z /lewej listy/ dodajemy je ot
      tak, dodając z obydwu robimy na ichnich jednomach ~+=~, a dodając z /prawej/
      dokonujemy /kopii/. Będzie tutaj pewna zabawa, ale może warto

****** szkic merge'u w poważnych językach
       #+begin_src ocaml
         type pseudo_mono = { p : int; exp : int }

         let rec merge_monos ll rl =
           match (ll, rl) with
           | [], [] -> []
           | _, [] -> ll
           | [], _ -> rl
           | lh::lt, rh::rt ->
              let c = compare lh.exp rh.exp in
              match c with
              | 0 -> { p = lh.p + rh.p; exp = lh.exp } :: merge_monos lt rt
              | -1 -> lh :: merge_monos lt rl
              | _ -> rh :: merge_monos ll rt
       #+end_src

       #+begin_src emacs-lisp
         (cl-defstruct mono poly exp)

         (defun merge-monos (l r)
           (if (null l) r
             (if (null r) l
               (let ((lexp (mono-exp (car l)))
                     (rexp (mono-exp (car r))))
                 (if (< lexp rexp)
                     (cons (car l) (merge-monos (cdr l) r))
                   (if (= lexp rexp)
                       (cons (make-mono
                              :poly (+ (mono-poly (car l)) (mono-poly (car r)))
                              :exp lexp)
                             (merge-monos (cdr l) (cdr r)))
                     (cons (car l) (merge-monos l (cdr r)))))))))
       #+end_src
***** operacji ~*=~ *нет*
      Nie ma żadnego sensu i użytku -- mnożąc wielomiany /nie chcemy zmieniać jednomianów/ -- każego
      użyjemy $n$ razy. To nie jest operacja, gdzie ze starego budujemy nowe...
***** negacja
      Ten pomysł ma jeszcze więcej sensu niż pierwotnie myślałem.

      Jak ma działać odejmowanie wielomianów? Zapewne fakt $p - q = p + (-q)$ bardzo ułatwi
      w pewnych aspektach tę sprawę. Można po prostu napisać, że bierzemy najpierw ~PolyNeg~
      i... oj. *oj*. =PolyNeg= zwraca *nowy wielomian*. Czyli dostaniemy $p$ i $q$,
      stworzymy $q_2 = -q$ i dopiero wtedy =PolyAdd= zwróci nam $r = p + q_2$... Ale
      przecież $q_2$ nam nie jest potrzebne później i musimy je jeszcze zniszczyć! Powoduje
      to masę niekoniecznego ględzenia.

      Tu znów warto byłoby mieć ~+=~. Wtedy rzecz by się zbanalniła. Negacja oczywiście jest
      wygodniejsza w formie ~p *= -1~ ponieważ chcemy zanegować go samego. Zatem
      #+begin_example
        p - q =
          nq = PolyClone(q);     # kopia
          nq *= -1;              # -q
          nq += p;               # -q + p
          return nq;
      #+end_example
      załatwiłoby sprawę...?
* Implementacja
** TODO dualizm koeficji
   Zachodzi ewidentnie pewien /dualizm/ swoisty w strefie koeficji (ang. /coefficient/)
   wielomianowych. Otóż jest dwuznacznośc pewna. Można albo zapisać je zarazem jako
   wielomian z pustą listą oraz jako jednomian $c x^0$. Wręcz tak trzeba je chyba trzymać
   mając listę dla $x^3 + x^2 + 5$ np. Ale jak wtedy to rozkminiać...

   1. komparator mondry
   2. nie tworzyć któregoś rodzaju
   3. ???

   Trzymanie jednomianu pojedynczego jako koeficji? być może to byłoby najlepsze. hm
   
*** rozw nr 1 -- *x^0 * c*
    Zgodnie z tym co żem napisał powyżej jako 1. W przyrodzie istnieć będą obydwa rodzaje
    koeficji (/yikes/).
    
    1. wielomian -- =(Poly) { .coeff = c, .list = NULL }=
    2. jednomowy wrapper -- =(Mono) { .p = PolyCoeff, .exp = 0 }= czyli w sensie
       matematycznym jest to $c * x^0$... Trochę głupie, wiem. Aczkolwiek chyba jest to
       *jedyny* sposób aby zachować integrację z dotychczasowym interfejsem. Wtedy trzeba
       dokonać przemyślunku jeszcze w tych kilku kwestiach:
       
**** dodawanie koeficji
     Mając koeficję typu pierwszego i dodając ją do wielomianu muszę ją zwrapować
     zawczasu. Czyli tworzę =MonoList= z tym wielomianem i ją wciskam w miejsce
     odpowiednie. jeśli w procesie dodawanie trafi mi się zerowy koeff, co wtedy? tj jeśli
     mam $x+1$ i dodam doń $-1$. Oczekiwałbym $x$. Musiałbym wtedy do funkcji insertującej
     się doglądać. to jest zdecydowane *TODO*. Hm.
     +Dotychczas dodawałem element i robiłem+
     +~+=~ na tracerze, ale teraz widzę, że być może słuszniej byłoby zrobić ~+=~ na nowym+
     +i jeśli niewyjdzie zero to podmiankę, a jeśli wyjdzie, to czyszczę co pod tracerem i+
     +robię jakoś relink. tj ~*tracer = &(*tracer)->tail~ -- podmieniam cały wskaźnik.+

     chociaż........... hm. być może jednak /lepiej/ zostawić tak jak jest. =MonoAddComp=
     zadziała i tak jedynie na tracerze i jego tail pozostanie bez szwanku. zatem w
     przypadku zerowania po prostu nisczę mono tracera i podstawiam pod niego jego ogon.

**** czy może mi się trafić wywołanie =is_coeff= na takim pseudo koefie?
     innymi słowy... czy powinienem dodać warunek do is coeff? *bardzo* by to
     popsuło. Muszę zatem po operacjach sprawdzać, czy nie został koef jedynie

*** nierozw nr 2 -- /lista jednoelementowa/
    
** TODO problem niemały -- =PolyAt=
   
*** rozw?
    Potencjalnie rozwiązałem tę zagwozdkę. Mając to swoje ~+=~ mogę wykonywać taką pętlę:
    #+begin_example
      PolyAt(p, x)
      {
        Poly res, mul;
        for Mono m in p->list do {
          mul = m.p * x^m->exp
          res += mul
          delete mul
        }

        return res.
      }
    #+end_example
    Czyli tworzę pomnożony przez koeficję zawsze i *kumsum*.

    minus: konieczność destrukcji wyniku mnożenia za każdym razem
*** prblm
    Czyli zamieniam zmienną na samym dole w jakąś wartość.
    \[ \sum_n p_n x^n \]
    co tu poczynić???

    mogę obliczyć oczywiśie potęgę. Wtedy awansują zmienne wszystkie. Czyli muszę jakby tę
    /listę list/ zde-awansować do /listy/. Mam
    #+begin_example
      +-----+
      | m   |  +--->  
      |     |  |
      |tail-----
      +-----+
    #+end_example
    takich komórek nie mało i każde =m= trzyma swoją listę też. Teraz chcę przelać tę listę
    do środka... Ech. Mógłbym wziąć pierwszą listę po prostu i robić =PolyAdd= każdej
    kolejnej.
    #+begin_example
      +-----------------------+    +-->  +-----------------------+   +--> ...
      | m { ax_1 + bx_1 + ... |    |     | m { cx_1 + dx_1 + ... |   |
      |                       |    |     |                       |   |
      |  x_0 = x^n        tl ------+     |  x_0 = x^n        tl -----+
      +-----------------------+          +-----------------------+

      ======>>>

      (ax^n + bx^n + cx^n + dx_n) x_0         ????
    #+end_example
    meaning -- flattuję listę. *ech*
** DONE arr v list
   Czy powinienem użyć na wielomian jednomianu (tj ten współczynnik) tablicy czy może raczej linked
   listy?
   | własność              | tablica       | linked lista            |
   |-----------------------+---------------+-------------------------|
   | utrzymanie kolejności | bad           | good                    |
   | alokacje              | good          | bad                     |
   | ile mem               | bad           | good                    |
   | prostota              | good          | bad                     |
   | free                  | good          | not good                |
   | indeksowanie          | good          | bad, ale czy potrzebne? |
   | nadmiarowa pamięć     | bad           | good                    |
   | wyszukiwanie          | $n$           | $n$                     |
   | dodanie przód         | $1$           | $n$                     |
   | dodanie tył           | ~$n~$ (amort) | $n$                     |
   | insert                | $n$, ale easy | $n$, ale hard           |
   | implementacja?        | mam już       | jeszcze nie             |
   | fajne rzeczy          | tak se        | masa -- patrz =ocaml=   |

   Są rzadkie więc na pewno nie warto trzymać tych z zerowymi współczynnikami.  Jednakże redukcja
   wyr. podobn. byłaby o wiele wygodniejsza z listą -- można trzymać po prostu w liście wynik mnożeń
   i wtedy się ułożą elegancko w kolejności potęgi.

** dodawanie
   coś à la merge sort z całą pewnością. to jest tabelarno-listowo analogicznie good. Warto by sobie
   rozpisać to z jakimś pseudo pattern matchingiem (zwłaszcza wersję listowną). swoją drogą dobre
   pytanie: czy jakimś zestawem makr da się osiągnąć pattern matching w C?

** mnożenie
   problematyczne -- jak rozsądzić podobieństwo wyrazów, gdy te powstają w różnej kolejności?

*** lista
    miałbym łatwą insercję w środek elegancko

    mógłbym użyć techniki [[https://www.youtube.com/watch?v=0ZEX_l0DFK0][triple ref pointerów]]
    
*** tablica
    insercja odpada. musiałbym wszystko zresztą sortować. Na pewno musiałbym mieć tutaj jakiegoś
    rodzaju osobne funkcje na dodanie jednomianu.
    
    pomysł np taki: dodawanie jednomianu $p x_i^n$ do wielomianowej tabliczki
    1. szukam po całej tablicy czegoś z $^n$
       - *jeśli znajduję* --> dodaję to =mono= jakąś inną funkcyjką do tego co już jest. bo mam
         $p x_i^n + q x_i^n = (p + q)x_i^n$ -- używam funkcji do dodawania.
       - *nie znajduję* w całej +lub mijam ten indeks+ (minięcie odpada gdyż dorzucam bez insercji)
         --> robię zwykłe =array_append= na =poly.arr= i dorzucam tam ten jednomian 
    2. dodaję kolejny jednomian
    3. jeśli nie ma kolejnych to mam każdej potęgi po sztuce, ale zlosowiałe -- sortuję całą tablicę
       jeśli brak kolejnych
* Pytania
  1. czy można jakoś gita ssh?
  2. czy raczej używanie tego danego gita mimu jest wskazane?
  3. lista, nie tabl?
  4. =PascalCase= to obowiązek?

* Rozumienie def
  Mamy sobie jednomiany. $m_i = p_{i+1} x_i^n$.
  
  Wtedy $p_{i+1} = \sum p_{i+2} m_{i+1}^k$
  
  Czyli każdy *jednomian* (=Mono=) ma swoją potęgę i jest na jakimś levelu. Level to jest to $i$
  stojące przy iksie. Prócz tego ma współczynnik $p$ będący /sumą jednomianów/ czyli
  *wielomianem*. Ten wielomian traktujemy jako lvl wyżej. Tj każdy jego jednomian składowy jest
  względem $x_{i+1}$.

** Diagram
   *Jednomian* typu $p x_0^n$ można ogólnie rozpatrzeć jako jednomian na poziomie $i$, z wykładnikiem
   $n$ i swoim *wielomianem* tj /przybocznymi jednomianami/ zsumowanymi (ale level wyżej --> $i+1$).

   Rycina następująca
   #+begin_example
     +---------+
     | Mono    |
     |         |
     | n, i    |
     |        p|
     +--------|+
              |
             Poly
              |
              +--> +------+     +------+     +------+
                   | Mono |  +  | Mono |  +  | Mono |  + ...
                   |      |     |      |     |      |
                   |n, i+1|     |n, i+1|     |n, i+1|
                   |    p |     |    c |     |   p/c|
                   +----|-+     +------+     +------+
                        |
                        +->...
   #+end_example
   gdzie mogą być różne $n$ wszędzie, ale te same $i$. Trochę to może być mylące, ale po prostu
   chodzi mi o to, że mają /jakieś/ potęgi, ale określone zmienne. Oznaczenie ~p/c~ oznacza, że albo
   jest tam kolejny wielomian (swoiście pogłębiając rekurencję) albo jest tam jakaś stała liczba i
   koniec.

   
